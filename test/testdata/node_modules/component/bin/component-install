#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program = require('commander');
var component = require('..');
var fs = require('fs');
var exists = fs.existsSync;
var utils = component.utils;
var log = utils.log;
var error = utils.error;
var url = require('url');
var path = require('path');
var resolve = path.resolve;

// options

program
  .usage('[name ...]')
  .option('-d, --dev', 'install development dependencies')
  .option('-r, --remotes <urls>', 'remotes to try installing from')
  .option('-o, --out <dir>', 'output components to the given <dir>', 'components')
  .option('-f, --force', 'force installation even if previously installed')
  .option('-v, --verbose', 'verbose output')

// examples

program.on('--help', function(){
  console.log('  Examples:');
  console.log();
  console.log('    # install deps in ./component.json');
  console.log('    $ component install');
  console.log();
  console.log('    # install a single component');
  console.log('    $ component install component/tip');
  console.log();
  console.log('    # install several components');
  console.log('    $ component install component/tip component/popover');
  console.log();
  console.log('    # shell brace expansion ftw');
  console.log('    $ component install component/{tip,popover,dialog}');
  console.log();
  console.log('    # install a specific tag / sha');
  console.log('    $ component install component/tip@8bf1ffc3f');
  console.log();
  console.log('    # install regular & development deps in .');
  console.log('    $ component install -d');
  console.log();
});

// parse argv

program.parse(process.argv);

// pkgs

var pkgs = program.args;

// install from ./component.json

var local = 0 == pkgs.length;

// component.json required

if (local && !exists('component.json')) utils.fatal('missing component.json');

// read json

var conf = loadConfig();

// install from ./component.json

if (local) {
  if (conf.dependencies) {
    pkgs = normalize(conf.dependencies);
  }

  if (conf.development && program.dev) {
    pkgs = pkgs.concat(normalize(conf.development));
  }

  if (conf.local) {
    conf.local.forEach(function(pkg){
      try {
        var deps = component.dependenciesOf(pkg, conf.paths);
        deps.map(normalize).forEach(function(deps){
          pkgs = pkgs.concat(deps);
        });
      } catch (err) {
        utils.fatal(err.message);
      }
    });
  }
}

// save to ./component.json

if (!local) {
  var key = program.dev ? 'development' : 'dependencies';

  conf[key] = conf[key] || {};
  pkgs.forEach(function(pkg){
    pkg = parsePackage(pkg);
    conf[key][pkg.name] = pkg.version || '*';
  });

  if (exists('component.json')) saveConfig();
}

// implicit remotes

conf.remotes = conf.remotes || [];

// explicit remotes

if (program.remotes) {
  conf.remotes = program.remotes.split(',').concat(conf.remotes);
}

// default to github

conf.remotes.push('https://raw.github.com');

// install

console.log();
pkgs.forEach(function(pkg){
  pkg = parsePackage(pkg);
  install(pkg.name, pkg.version || 'master');
});

// parse package identifier

function parsePackage(pkg) {
  var parts = pkg.split('@');
  return {
    name: parts.shift(),
    version: parts.shift()
  };
}

// map deps to args

function normalize(deps) {
  return Object.keys(deps).map(function(name){
    return name + '@' + deps[name];
  });
}

// reporter

function report(pkg, options) {
  options = options || {};
  if (pkg.inFlight) return;
  log('install', pkg.name + '@' + pkg.version);

  pkg.on('error', function(err){
    if (err.fatal) {
      error(err.message);
      process.exit(1);
    }

    utils.warn('warning', err.message);
  });

  if (program.verbose) {
    pkg.on('dep', function(dep){
      log('dep', dep.name + '@' + dep.version);
      report(dep, options);
    });

    pkg.on('exists', function(dep){
      log('exists', dep.name + '@' + dep.version);
    });

    pkg.on('file', function(file){
      log('fetch', pkg.name + ':' + file);
    });
  }

  pkg.on('end', function(){
    log('complete', pkg.name);
  });
}

// padding

process.on('exit', function(){
  console.log();
});

/**
 * Install package `name` at the given `version`
 * from all specified remotes.
 *
 * @param {String} name
 * @param {String} version
 * @api private
 */

function install(name, version) {
  touch(program.out);

  // kick off installation
  var pkg = component.install(name, version, {
    dest: program.out,
    force: program.force,
    dev: program.dev,
    remotes: conf.remotes,
    concurrency: 10
  });

  report(pkg);

  // TODO: add callback
  pkg.install();
}

/**
 * Touch `path` when present.
 *
 * @param {String} path
 * @api private
 */

function touch(path) {
  try {
    fs.utimesSync(path, new Date, new Date);
  } catch (err) {
    // ignore
  }
}

/**
 * Read / create ./component.json.
 *
 * @return {Object}
 * @api private
 */

function loadConfig() {
  var path = resolve('component.json');
  if (exists('component.json')) {
    return require(path);
  } else {
    return {};
  }
}

/**
 * Save configuration.
 *
 * @api private
 */

function saveConfig() {
  var path = resolve('component.json');
  fs.writeFileSync(path, JSON.stringify(conf, null, 2));
}
